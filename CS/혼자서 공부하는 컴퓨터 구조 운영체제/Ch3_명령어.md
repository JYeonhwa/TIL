저급 언어와 고급 언어



우리가 만드는 소스 코드들은 나중에 컴퓨터에서 명령어로 바뀝니다!

즉, 고급 언어에서 저급 언어로 변환된다는 의미입니다.





고급 언어 - 사람이 이해할 수 있지만, 컴퓨터는 이해할 수 없는 언어

저급 언어 - 반대로 컴퓨터는 이해하지만, 사람이 이해하기 어려운 언어



저급 언어에는 두 종류가 있습니다.

- 기계어 = 0과 1의 명령어 비트로 이루어진 언어

- 어셈블리어 = 0과 1로 표현된 명령어를 사람이 읽기 편한 형태로 번역한 언어



그럼 어셈블리어도 고급 언어 아니냐라고 할 수 있지만

사실 어셈블리어와 고급 언어의 가장 큰 차이는

기계어와 문법이 비슷하냐 아니냐인 듯 합니다!



그래서 하드웨어와 밀접하게 일하는 임베디드, 게임, 정보 보안 분야의 경우 어셈블리어를 자주 사용한다고 합니다.




어셈블리어 예시


어셈블리어를 알면 기계어가 어떻게 동작하는지 어림잡을 수 있으니,

고급 언어를 사용하는 개발자들도 알아두면 좋을 언어인 것 같습니다.



고급 언어 >> 저급 언어 변환 방식



고급 언어를 저급 언어로 변환할 때 사용하는 방식은 크게 두 가지로 볼 수 있습니다.



1. 컴파일 언어 ex. C, C++

: 컴파일러를 통해 소스 코드 전체를 저급 언어(목적 코드)로 변환하여 실행시키는 고급 언어.

  하나라도 오류가 있으면 컴파일 실패.

2. 인터프리터 언어 ex. Python

: 인터프리터에 의해 소스 코드를 한 줄씩 변환하며 실행하는 고급 언어.

  오류가 나타나기 전까지는 실행.



* C, C++을 제외하고는 컴파일 언어와 인터프리터 언어의 경계가 모호한 경우가 많습니다.

  Java의 경우는 컴파일과 인터프리트를 동시에 수행하고 Python도 컴파일이 없는 것은 아니라고 합니다.



일반적으로 컴파일 언어가 인터프리터 언어보다 실행 속도가 빠릅니다!

컴파일 언어의 목적 코드는 컴퓨터가 전체적으로 이해할 수 있는 언어지만

인터프리터 언어는 소스 코드 마지막까지 한줄씩 해석되기 때문입니다.







과연 목적 코드가 있는 목적 파일은 .exe처럼 실행 파일로 사용할 수 있을까요?



Nooooo...



목적 코드를 실행 파일로 바꾸려면 링킹이라는 작업을 해야합니다.



링킹이 뭐냐!

main.c 소스 코드에 solution.c 파일에 있는 함수 A를 실행하는 코드가 있다고 가정합시다.

두 파일을 각각 컴파일하고 나서 실행 파일로 바꾸려면

main.c에 없는 함수 A의 위치를 이어줘야되는데, 이 작업을 링킹이라고 합니다.





명령어 구조



명령어는

명령어에서 수행할 연산인 연산 코드와

그 연산에 사용될 데이터를 나타내는 값인 오퍼랜드(operand)로 이루어져있습니다.



연산 코드의 종류는 네 가지가 있습니다!

- 데이터 전송

   (MOVE, STORE, LOAD or FETCH, PUSH, POP)



- 산술/논리 연산

   (ADD/SUBSTRACT/MULTIFLY/DIVIDE, INCREMENT++/DECREMENT--, AND/OR/NOT, COMPARE)



- 제어 흐름 변경

   (JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN)



- 입출력 제어

   (READ/INPUT, WRITE/OUTPUT, START IO, TEST IO)



이름만 봐도 직관적으로 느낌이 옵니다.







오퍼랜드는 실제 데이터 또는 메모리나 레지스터의 주소가 올 수 있으며,

보통은 주소값을 넣어 사용합니다.



또한, 오퍼랜드는 명령어 내부에 아예 없을 수도, 여러 개일 수도 있습니다!

오퍼랜드의 갯수에 따라 0-주소 명령어, 1-주소 명령어 등으로 부릅니다.





주소 지정 방식



ㅠ 한 번 썼는데 날아갔네요...

복습한다치고 한 번 더 씁니다.



1. 즉시 주소 지정 방식

: 오퍼랜드 필드에 연산에 사용할 데이터를 직접 명시하는 방법. 표현할 수 있는 데이터의 종류는 적어지지만 메모리에 접근하는 과정이 없기에 상대적으로 속도가 빠릅니다.



2. 직접 주소 지정 방식

: 오퍼랜드 필드에 데이터의 유효 주소를 직접 명시하는 방법. 1번보다는 표현 가능한 데이터가 늘었지만, 여전히 유효 주소를 표현할 수 있는 범위에 제한이 있습니다.



3. 간접 주소 지정 방식

: 오퍼랜드 필드에 데이터의 유효 주소의 주소를 명시하는 방법. 다른 방법보다 상대적으로 표현 범위 제한은 줄어들지만 메모리에 두 번 접근하면서 속도가 느려지는 단점이 있습니다.



4. 레지스터 주소 지정 방식

: 2번과 비슷하게 오퍼랜드 필드에 데이터가 저장된 레지스터를 명시하는 방법. 메모리에 접근하는 것보다 속도는 빠르지만 역시나 레지스터의 크기에 따라 데이터 표현의 폭이 줄어든다는 단점이 있습니다.



5. 레지스터 간접 주소 지정 방식

: 오퍼랜드 필드에 데이터의 주소를 가진 레지스터를 명시하는 방법. 연산에 사용할 데이터는 메모리에, 그 주소는 레지스터에 저장합니다. 3번과 비슷한 방식이지만 레지스터를 거치면서 속도가 더 빠릅니다.





이 아래부터는 4장의 레지스터 부분을 참고하고 오시는 편이 이해하기 편할 수 있습니다.



Chapter 4. CPU의 작동 원리

https://bighamham.tistory.com/6





6. 스택 주소 지정 방식

: 스택 포인터라는 레지스터와 스택 구조를 이용한 주소 지정 방식. 메모리 내에 스택 영역으로 주소 공간을 지정해놓고 스택 포인터의 주소를 변경해가면서 스택 내의 데이터를 꺼내쓰는 방법입니다.

* 스택 - 후입선출(LIFO)의 자료 구조로 가장 최근에 저장한 값을 조회할 때 활용되는 구조.



7. 변위 주소 지정 방식

: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 지정하는 방식. 이 방식은 크게 두 가지로 나눠집니다.

  1) 상대 주소 지정 방식

      오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식.

      현재 접근하려는 메모리 주소를 기준으로 어느 주소에 접근할지에 대한 정보가 저장되어 있습니다.

      if문과 유사하게 분기 처리를 할 때 사용됩니다.

  2) 베이스 레지스터 주소 지정 방식

      오퍼랜드와 베이스 레지스터 값을 더하여 유효 주소를 얻는 방식.

      베이스 레지스터 안의 기준으로부터 얼마나 떨어져있는 주소에 접근할지 정합니다. 

